// watch2.ini
// writing to LED screen, want three different watch displays
// screen 0 : time, date, weather, location
// screen 1 : chronometer, minuter
// screen 2 : connetion to health band
// LED screen specifications : green tab ST7735 128 x 160
// setup for this screen can be found in Documents/PlatformIO/Projects/watch2/.pio/libdeps/esp32doit-devkit-v1/TFT_eSPI
  // #define ST7735_GREENTAB2
  // #define TFT_MOSI 23
  // #define TFT_SCLK 18
  // #define TFT_CS   5  // Chip select control pin
  // #define TFT_DC   21  // Data Command control pin
  // #define TFT_RST  -1  // Set TFT_RST to -1 if display RESET is connected to ESP32 board RST

// Sets the size of text that follows. The default size is “1”. Each change in size increases the text by 10 pixels in height. That is, size 1 = 10 pixels, size 2 =20 pixels, and so on.



#include <Arduino.h>

#include <TFT_eSPI.h> // drawing on LED screen. Library found on platformio registry
#include "SPI.h" // communication with LED screen 


 // Connect to internet for weather
//#include <HTTPClient.h>
#include <ArduinoJson.h> // planchon
#include <WiFiClientSecure.h>
#include "time.h"

//#include "freertos/event_groups.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "esp_timer.h" // esp-idf has its own way to create software timers

#define BOTTOMBUTTON 34
static TimerHandle_t oneShotToZeroTimer = NULL;
static TimerHandle_t minuteAutoReloadTimer = NULL;
int screenNum = 0; // which screen to present

TFT_eSPI tft = TFT_eSPI();

// const char* ssid = "Cafe Faro Lennoxville";
// const char* password = "CAFE1982";
const char* ssid = "twitch.tv/quin69";
const char* password = "Onigoroshi69";

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 3600 * -4;
const int   daylightOffset_sec = 3600 * 0;
const char* googleHost = "www.googleapis.com";
String googleGeolocation = "/geolocation/v1/geolocate?key="; // must be post
String googleMapsKey = "AIzaSyA8CLgFPtFWO3Ga5guEjC6Os3_NVDzaBng";
String googleGeocoding;
String googleTimezone;
// String openWeatherKey = "3e3511f75388f965df34a336d34adb2d";
// String pathToCityWeather = "http://api.openweathermap.org/data/2.5/weather?q=Nanaimo,ca&APPID=";
#define BIT_0 (1<<0)
#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS(60000)
// static EventGroupHandle_t xEventGroup;
TaskHandle_t printScreenHandle = NULL;
TaskHandle_t screen0Handle = NULL;
TaskHandle_t screen1Handle = NULL;
TaskHandle_t screen2Handle = NULL;

//*****************************************************************************
// Callbacks
void writeTimeCallback(TimerHandle_t xTimer){
  Serial.println("timerCallback");
  if(screenNum==0){
    struct tm timeinfo;
    getLocalTime(&timeinfo);
    char time[50];
    strftime(time, sizeof(time), "%H:%M", &timeinfo);
    tft.drawString(time, 0, 5, 6); // text, xpos, ypos, size
    if(timeinfo.tm_hour == 0 && timeinfo.tm_min == 0){ // Still need to verify
      char date[50];
      strftime(date, sizeof(date), "%a %B %e", &timeinfo);
      tft.drawString(date, 5, 50, 2);
    }
    if((uint32_t)pvTimerGetTimerID(xTimer) == 0){
      xTimerStart(minuteAutoReloadTimer,0);
    }
  }
  else{
    xTimerStop(xTimer, 0);
  }
}
//*****************************************************************************
// ISR
void IRAM_ATTR isr_changeScreen(){ // no Serial.print in an ISR
  BaseType_t xHigherPriorityTaskWoken;
  // BaseType_t xResult;
  xHigherPriorityTaskWoken = pdFALSE;
  // xResult = xEventGroupSetBitsFromISR(
  //   xEventGroup,                // event group
  //   BIT_0,                      // bits to set
  //   &xHigherPriorityTaskWoken); // false 
  // //vTaskNotifyGiveFromISR(printScreenHandle, xHigherPriorityTaskWoken);
  // if(xResult != pdFAIL){
  //   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  // }
  vTaskNotifyGiveFromISR(printScreenHandle, &xHigherPriorityTaskWoken);
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
//*****************************************************************************
// Tasks
void printScreen(void *pvParameters){
  for(;;){
    // EventBits_t bit;
    // bit = xEventGroupWaitBits(
    //   xEventGroup,             // event group
    //   BIT_0,                   // bit to wait for
    //   pdTRUE,                  // clears bit we are waiting for when TRUE
    //   pdFALSE,                 // waits for all bits when TRUE (AND), or FALSE (OR) 
    //   10000/portTICK_RATE_MS); // maximum wait 10 seconds
    uint32_t ulEventsToProcess;

    ulEventsToProcess = ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    if(ulEventsToProcess != 0){
      screenNum = (screenNum+1) % 3; // 3 possible screen choices
      Serial.print("printScreen, screenNum = ");
      Serial.print(screenNum);
    // if((bit & BIT_0) != 0){ // if bit was set
      switch(screenNum){
        case 0:
          xTaskNotifyGive(screen0Handle);
          break;
        case 1:
          xTaskNotifyGive(screen1Handle);
          break;
        case 2:
          xTaskNotifyGive(screen2Handle);
          break;
        default:
          Serial.println("screenNum out of range");
      }
    }
  }
}

void screen0(void *pvParameters){ // time, date, weather, location
  for(;;){
    uint32_t ulEventsToProcess;
    ulEventsToProcess = ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // nust set INCLUDE_vTaskSuspend to 1 in FreeRTOSConfig.h
    if(ulEventsToProcess != 0){
      Serial.println(" screen0");






      // tft.fillScreen(TFT_BLACK);
      // tft.setTextColor(TFT_WHITE, TFT_BLACK); // font, background
      // tft.drawString(time, 0, 5, 6); // text, xpos, ypos, size
      // tft.drawString(date, 5, 50, 2);
      // tft.drawString("Nanaimo, CA", 5, 120, 2);
      // tft.drawString("24/9C", 5, 140, 2);

      // xTimerChangePeriod(oneShotToZeroTimer, pdMS_TO_TICKS((60-timeinfo.tm_sec)*1000), 0);
    }
  }
}

void screen1(void *pvParameters){ // screen 1 chronometer
  for(;;){
    uint32_t ulEventsToProcess;
    ulEventsToProcess = ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // nust set INCLUDE_vTaskSuspend to 1 in FreeRTOSConfig.h
    if(ulEventsToProcess != 0){
      Serial.println(" screen1");
      tft.fillScreen(TFT_RED);
      tft.setTextColor(TFT_WHITE, TFT_RED); // font, background
      tft.drawString("CHRONOMETER", 5, 120, 2);
      tft.drawString("START", 5, 140, 2);
    }
  }
}

void screen2(void *pvParameters){ // screen 2 connects to health band
  for(;;){
    uint32_t ulEventsToProcess;
    ulEventsToProcess = ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // nust set INCLUDE_vTaskSuspend to 1 in FreeRTOSConfig.h
    if(ulEventsToProcess != 0){
      Serial.println(" screen2");
      tft.fillScreen(TFT_BLUE);
      tft.setTextColor(TFT_WHITE, TFT_BLUE); // font, background
      tft.drawString("Heart Rate", 5, 120, 2);
      tft.drawString("Pulse", 5, 140, 2);
    }
  }
}

//*****************************************************************************
// Setup
void setup() {  
  Serial.begin(9600);
  delay(1000);
  Serial.println("baud rate 9600");
  
  
  WiFi.begin(ssid, password);
  Serial.println("\nConnecting to network");
  // uint8_t status = WiFi.waitForConnectResult();
  if (WiFi.waitForConnectResult() == WL_CONNECTED) {       
    Serial.println("Connected to the WiFi network");
    Serial.print("Local ESP32 IP: ");
    Serial.println(WiFi.localIP());
  } 

  // geolocate - get lat and lng
  time_t now;
  struct tm timeinfo;
  configTime(0,0, ntpServer);
  getLocalTime(&timeinfo);
  time(&now);
  WiFiClientSecure client;
  StaticJsonDocument<75> doc; //https://arduinojson.org/v6/assistant
  String jsonString = "";
  String lat = "";
  String lng = "";

  Serial.println("\nStarting connection to server...");
  client.setInsecure();
  if (!client.connect(googleHost, 443))
    Serial.println("Connection failed!");
  else {
    Serial.println("GEOLOCATE - Connected to server!");
    // Make a HTTP request:
    //client.println("POST https://www.googleapis.com/geolocation/v1/geolocate?key=AIzaSyA8CLgFPtFWO3Ga5guEjC6Os3_NVDzaBng HTTP/1.0");
    client.println("POST https://" + (String)googleHost + googleGeolocation + googleMapsKey + " HTTP/1.0");
    client.println("Host: " + (String)googleHost);
    client.println("Connection: close");
    client.println("Content-Type: application/json");
    client.println("Content-Length: 0");
    client.println();

    while (client.connected()) {
      String line = client.readStringUntil('\n');
      if (line == "\r") {
        Serial.println("headers received");
        break;
      }
    }

    while (client.available()) {
      char c = client.read();
      Serial.write(c);
      jsonString += c;
    }

    client.stop();
  }



    char* jsonChar = &jsonString[0];

    DeserializationError error = deserializeJson(doc, jsonChar);
    if (error) {
      Serial.print(F("deserializeJson() failed: "));
      Serial.println(error.f_str());
    }
    else{
      String lat  = doc["location"]["lat"]; // 45.4197248
      String lng  = doc["location"]["lng"]; // -71.8667776
      Serial.println("=== lat lng test ===");
      Serial.println(lat);
      Serial.println(lng);
      if (!client.connect("maps.googleapis.com", 443))
        Serial.println("Connection failed!");
      else {
        Serial.println("TIME ZONE - Connected to server!");
        // Make a HTTP request:
        client.println("POST https://maps.googleapis.com/maps/api/timezone/json?location=" + lat + "," + lng + "&timestamp=" + time(&now) + "&key=" + googleMapsKey + " HTTP/1.0");

        client.println("Host: maps.googleapis.com");
        client.println("Connection: close");
        client.println("Content-Type: application/json");
        client.println("Content-Length: 0");
        client.println();

        while (client.connected()) {
          String line = client.readStringUntil('\n');
          if (line == "\r") {
            Serial.println("headers received");
            break;
          }
        }
        jsonString.clear();
        while (client.available()) {
          char c = client.read();
          Serial.write(c);
          jsonString += c;
        }

        client.stop();
      }
      // it would be rice to be able to filter json returned so that we do not have timeZoneId and timeZoneName
      // looks like it must be done on the client side? But then why do they say that certain responses are optional...
      char* jsonChar = &jsonString[0];

      DeserializationError error = deserializeJson(doc, jsonChar);
      if (error) {
        Serial.print(F("deserializeJson() failed: "));
        Serial.println(error.f_str());
      }
      else{}
    }

  

  // if (!getLocalTime(&timeinfo)) {
  //   Serial.println("Failed to obtain time");
  // }
  char time[50];
  strftime(time, sizeof(time), "%H:%M", &timeinfo);
  char date[50];
  strftime(date, sizeof(date), "%a %B %e", &timeinfo);

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer); // We configure the NTP server


  tft.init();

  pinMode(BOTTOMBUTTON, INPUT);
  attachInterrupt(BOTTOMBUTTON, isr_changeScreen, FALLING);

  // xEventGroup = xEventGroupCreate();

  xTaskCreate(
    screen0,    // name of function                        
    "screen0",  // descriptive name for task (for debugging purposes)
    10000,      // stack size in words 
    NULL,       // parameter
    4,          // priority
    &screen0Handle);      // passes handle to task being created
  xTaskCreate(screen1, "screen1", 10000, NULL, 4, &screen1Handle);
  xTaskCreate(screen2, "screen2", 10000, NULL, 4, &screen2Handle);
  xTaskCreate(printScreen, "printScreen", 10000, NULL, 3, &printScreenHandle);

  oneShotToZeroTimer = xTimerCreate("oneshot", mainAUTO_RELOAD_TIMER_PERIOD, pdFALSE, (void*)0, writeTimeCallback);

  minuteAutoReloadTimer = xTimerCreate("auto-reload timer", mainAUTO_RELOAD_TIMER_PERIOD, pdTRUE, (void*)1, writeTimeCallback);

  //xTaskNotifyGive(screen0Handle); 

}

void loop() {}
